<!DOCTYPE html>
<html>
    <head>
    <!-- Fun compatability things -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">                  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="shortcut icon" href="/assets/images/favicon.ico">

    <!-- Information about this site -->
    <title>Reading Rust Function Signatures</title>
    <meta name="description" content="Exploring, fascinating and amusing" />

    <!-- Various Twitter related content. -->
    
        <meta name="twitter:card" content="summary">
        <meta name="twitter:image" content="http://0.0.0.0:4000/assets/images/cover.jpg">
    
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    
        <meta name="twitter:title" content="Reading Rust Function Signatures">
    
    
        <meta name="twitter:description" content="&lt;p&gt;In Rust, function signatures tell a story. Just from glancing at the signature of a function an experienced Rust user can tell much of the functions behaivor.&lt;/p&gt;

">
    

    <!-- Talk about the homepage and the rss feed. -->
    <link rel="canonical" href="http://0.0.0.0:4000">
    <link rel="alternate" type="application/rss+xml" href="/feed.xml">

    <!-- Stylesheets are fun -->
    <link rel="stylesheet" href="/assets/font/fira_code.css">
    <link rel="stylesheet" type="text/css" media="screen" href="/assets/main.css" />

    <!-- Include Katex if it's necessary. -->
    

    <script defer>
        // Create captions from Alt tags
        document.addEventListener("DOMContentLoaded", function(event) {
            Array.from(document.querySelectorAll("main img")).forEach(function (item) {
                if (item.attributes['alt']) {
                    var caption = document.createElement("figcaption");
                    caption.innerHTML = item.attributes['alt'].value;
                    item.outerHTML = "<figure>" + item.outerHTML + caption.outerHTML + "</figure>";
                }
            });
        });
    </script>
</head>


    <body>
        <header>
  <div id="cover-wrapper">
    
      <img id="cover" src="/assets/images/cover.jpg">
    
  </div>

  <div class="title">
    
      <h1><a href="/">Reading Rust Function Signatures</a></h1>
    
  </div>


  <nav id="pages">
    <ul>
      <li><a href="/">Index</a></li>
      
        
          <li>
            <a class="" href="/about/">
              About
            </a>
          </li>
        
      
        
      
        
      
        
      
        
          <li>
            <a class="" href="/projects/">
              Projects
            </a>
          </li>
        
      
        
          <li>
            <a class="" href="/tags/">
              Tags
            </a>
          </li>
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    </ul>
  </nav>
</header>


<main>
    <article>
        <p>In Rust, function signatures tell a story. Just from glancing at the signature of a function an experienced Rust user can tell much of the functions behaivor.</p>

<p>In this article we’ll explore some signatures and talk about how to read them and extract information from them. While exploring, you can find many great function signature examples in the <a href="https://doc.rust-lang.org/stable/std/">Rust API docs</a>. You can play around on the <a href="https://play.rust-lang.org/">Playpen</a>.</p>

<p>This article assumes some knowledge of Rust, glossing over a bit of the <a href="https://doc.rust-lang.org/stable/book/README.html">book</a> should be quite sufficient if you are lacking that but have programmed before.</p>

<p>If you’re used to programming in something like Python or Javascript, this all may seem a bit foreign to you. I hope by the end of it that you’re convinced this additional information is both a good thing, and that it is not something you often have in dynamically typed languages.</p>

<p>If you’re used to C++, C, or the other systemsy languages hopefully this should all seem very familiar, despite the syntax differences. Ideally by the end of your article you’ll think more about your function signatures as you write them!</p>

<h1 id="baby-steps">Baby Steps</h1>

<p>Your first function definition in Rust almost definitely looks like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>

<p>So since you’ve already most likely wrote this let’s start here!</p>

<ul>
  <li><code class="highlighter-rouge">fn</code>: is the syntax which tells Rust we’re declaring a function.</li>
  <li><code class="highlighter-rouge">main</code>: is the name of the function. <code class="highlighter-rouge">main</code> is special because it’s what the program invokes when built and run as a binary. Function names are always <code class="highlighter-rouge">snake_case</code> and not <code class="highlighter-rouge">camelCase</code>.</li>
  <li><code class="highlighter-rouge">()</code>: Is the arguments list. In this case, <code class="highlighter-rouge">main</code> accepts no arguments.</li>
  <li><code class="highlighter-rouge">{}</code>: Are the delimiters for the inside of a function. In this case, it’s empty.</li>
</ul>

<p>So what would we write for a function that does nothing useful?</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">do_nothing_useful</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Great, now you too can do nothing useful!</p>

<h1 id="visibility">Visibility</h1>

<p>By default, all functions are private and cannot be used outside of the module they are in. Making them usable by a different module is simple.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mod</span> <span class="n">dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">private_function</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">public_function</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c">// Optional to avoid `foo::`</span>
<span class="k">use</span> <span class="nn">dog</span><span class="p">::</span><span class="n">public_function</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">dog</span><span class="p">::</span><span class="nf">public_function</span><span class="p">();</span>
    <span class="c">// With `use`</span>
    <span class="nf">public_function</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Like mutability, Rust is conservative in its assumptions about things like visibility. If you try to use a private function the compiler will let you know and help point you to where you need to make the function public.</p>

<p>If you have a function like <code class="highlighter-rouge">foo::bar::baz::rad()</code> in your project and want to make it usable as <code class="highlighter-rouge">foo::rad()</code> add <code class="highlighter-rouge">pub use bar::baz::rad;</code> to your <code class="highlighter-rouge">foo</code> module. This is called re-exporting.</p>

<h1 id="simple-parameters">Simple Parameters</h1>

<p>No longer happy with <code class="highlighter-rouge">do_nothing_useful()</code> you decide to adopt a dog. Good for you! Now you have a new problem, you have to walk it and play with it!</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">walk_dog</span><span class="p">(</span><span class="n">dog_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">fn</span> <span class="nf">play_with</span><span class="p">(</span><span class="n">dog_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">game_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Parameters are declared <code class="highlighter-rouge">variable_name: Type</code>, and are comma seperated. But c’mon! Our dog is a lot more than just a <code class="highlighter-rouge">String</code>! Good news, you can use your own types too.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Dog</span><span class="p">;</span>  <span class="c">// Let's not go overboard.</span>
<span class="k">struct</span> <span class="n">Game</span><span class="p">;</span> <span class="c">// Simple types in demos!</span>

<span class="k">fn</span> <span class="nf">walk_dog</span><span class="p">(</span><span class="n">dog</span><span class="p">:</span> <span class="n">Dog</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">fn</span> <span class="nf">play_with</span><span class="p">(</span><span class="n">dog</span><span class="p">:</span> <span class="n">Dog</span><span class="p">,</span> <span class="n">game</span><span class="p">:</span> <span class="n">Game</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Great, looking better already. Let’s get that awesome day started.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rover</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">;</span>
    <span class="nf">walk_dog</span><span class="p">(</span><span class="n">rover</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">fetch</span> <span class="o">=</span> <span class="n">Game</span><span class="p">;</span>
    <span class="nf">play_with</span><span class="p">(</span><span class="n">rover</span><span class="p">,</span> <span class="n">fetch</span><span class="p">);</span> <span class="c">// Compiler Error!</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Whoa whoa! That’s a perfectly good day the compiler is totally <em>ruining</em> for us! Rover is going to be super sad.</p>

<p>Let’s look at the error:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;anon&gt;:11:15: 11:20 error: use of moved value: `rover`
&lt;anon&gt;:11     play_with(rover, fetch);
                        ^~~~~
&lt;anon&gt;:9:14: 9:19 note: `rover` moved here because it has type `Dog`, which is non-copyable
&lt;anon&gt;:9     walk_dog(rover);
                      ^~~~~
</code></pre></div></div>

<p>Here the compiler is telling us that <code class="highlighter-rouge">rover</code> was <em>moved</em> when we passed it into <code class="highlighter-rouge">walk_dog()</code>. That’s because <code class="highlighter-rouge">fn walk_dog(dog: Dog) {}</code> accepts a <code class="highlighter-rouge">Dog</code> value and we haven’t tell the compiler they are copyable! Values with <code class="highlighter-rouge">Copy</code> are implictly copied when passed to functions. You can make something <code class="highlighter-rouge">Copy</code> by adding <code class="highlighter-rouge">#[derive(Copy)]</code> above the declaration.</p>

<p><strong>We’re going to keep <code class="highlighter-rouge">Dog</code> not copyable because, gosh darnit, you can’t copy dogs.</strong> So how do we fix this?</p>

<p>We could clone <code class="highlighter-rouge">rover</code>. But our <code class="highlighter-rouge">Dog</code> struct isn’t <code class="highlighter-rouge">Clone</code> either! <code class="highlighter-rouge">Clone</code> means we can explicitly make a copy of an object. You can make something <code class="highlighter-rouge">Clone</code> just like you did as <code class="highlighter-rouge">Copy</code>. To clone our dog you can do <code class="highlighter-rouge">rover.clone()</code></p>

<p>But really neither of those possible solutions solved the real problem: <em>We want to walk and play with the same dog!</em></p>

<h1 id="borrowing">Borrowing</h1>

<blockquote>
  <p>Can I borrow your dog?</p>
</blockquote>

<p>Instead of moving our <code class="highlighter-rouge">Dog</code> into the <code class="highlighter-rouge">walk_dog()</code> function we really just want to <em>lend</em> the function our <code class="highlighter-rouge">Dog</code>. When you walk your dog it (generally) ends up coming back to the house with you, right?</p>

<p>Rust uses <code class="highlighter-rouge">&amp;</code> to symbolize a borrow. Borrowing something tells the compiler that when the function is done the ownership of the value returns back to the caller.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">walk_dog</span><span class="p">(</span><span class="n">dog</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Dog</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">fn</span> <span class="nf">play_with</span><span class="p">(</span><span class="n">dog</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Dog</span><span class="p">,</span> <span class="n">game</span><span class="p">:</span> <span class="n">Game</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>There are immutable borrows as well as mutable borrows (<code class="highlighter-rouge">&amp;mut</code>). You can have an immutable borrow passed to any number of things at once, and a mutable borrow only passed to one thing at a time. This provides data safety.</p>

<p>So our new borrowing functions don’t really cut it, do they? We can’t even mutate the <code class="highlighter-rouge">Dog</code>! Let’s try anyways to see the error message.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="n">walked</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">walk_dog</span><span class="p">(</span><span class="n">dog</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Dog</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dog</span><span class="py">.walked</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rover</span> <span class="o">=</span> <span class="n">Dog</span> <span class="p">{</span> <span class="n">walked</span><span class="p">:</span> <span class="k">false</span> <span class="p">};</span>
    <span class="nf">walk_dog</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rover</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rover</span><span class="py">.walked</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As we expected:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;anon&gt;:6:5: 6:22 error: cannot assign to immutable field `dog.walked`
&lt;anon&gt;:6     dog.walked = true;
             ^~~~~~~~~~~~~~~~~
error: aborting due to previous error
</code></pre></div></div>

<p>Changing the function signature to <code class="highlighter-rouge">fn walk_dog(dog: &amp;mut Dog) {}</code> and updating our <code class="highlighter-rouge">main()</code> we can solve this.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rover</span> <span class="o">=</span> <span class="n">Dog</span> <span class="p">{</span> <span class="n">walked</span><span class="p">:</span> <span class="k">false</span> <span class="p">};</span>
    <span class="nf">walk_dog</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">rover</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rover</span><span class="py">.walked</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see, the function signature tells the programmer <em>if a value is mutable</em> and <em>if the value is consumed or referenced</em>.</p>

<h1 id="returning">Returning</h1>

<p>Let’s revisit exactly <em>how</em> we get Rover, because thats how we can explore return types! Let’s say we want a function <code class="highlighter-rouge">adopt_dog()</code> which takes a name and gives us a <code class="highlighter-rouge">Dog</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">walked</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">adopt_dog</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="n">Dog</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="n">walked</span><span class="p">:</span> <span class="k">false</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rover</span> <span class="o">=</span> <span class="nf">adopt_dog</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Rover"</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rover</span><span class="py">.name</span><span class="p">,</span> <span class="s">"Rover"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So the <code class="highlighter-rouge">-&gt; Dog</code> part of the function signature tells us that the function returns a <code class="highlighter-rouge">Dog</code>. Note that the <code class="highlighter-rouge">name</code> is <em>moved</em> in and given to the dog, not copied or cloned.</p>

<h1 id="inside-traits">Inside Traits</h1>

<p>If you’re implementing functions in a trait you also have access the following two tools:</p>

<ul>
  <li>The <code class="highlighter-rouge">Self</code> return type which represents the current type.</li>
  <li>The <code class="highlighter-rouge">self</code> parameter which specifies the borrowing/moving/mutability of the structure instance. In <code class="highlighter-rouge">walk()</code> below we take a mutable borrow, a bare <code class="highlighter-rouge">self</code> moves the value.</li>
</ul>

<p>An example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// ... `Dog` struct from before.</span>
<span class="k">impl</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">adopt</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">Dog</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="n">walked</span><span class="p">:</span> <span class="k">false</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">walk</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.walked</span> <span class="o">=</span> <span class="k">true</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rover</span> <span class="o">=</span> <span class="nn">Dog</span><span class="p">::</span><span class="nf">adopt</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Rover"</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rover</span><span class="py">.name</span><span class="p">,</span> <span class="s">"Rover"</span><span class="p">);</span>
    <span class="n">rover</span><span class="nf">.walk</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rover</span><span class="py">.walked</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="generics">Generics</h1>

<p>Let’s face it, there are a lot of different kinds of dogs! But moreso, there are a lot of types of animals! Some of these we might want to walk too, like our <code class="highlighter-rouge">Bear</code>.</p>

<p>Generics let us do this. We can have a <code class="highlighter-rouge">Dog</code> and <code class="highlighter-rouge">Bear</code> struct that implement the <code class="highlighter-rouge">Walk</code> trait, then have a <code class="highlighter-rouge">walk_pet()</code> function accept any <code class="highlighter-rouge">Walk</code> traited structure!</p>

<p>Generics are specified to functions in between the name and the parameters using sharp brackets. The important thing to note about generics is when you’re accepting a generic <em>you may only use the functions from the constraints</em>. This means that if you pass a <code class="highlighter-rouge">Read</code> to a function that wants <code class="highlighter-rouge">Write</code>, it still can’t <code class="highlighter-rouge">Read</code> in it unless the constraints include it.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Dog</span> <span class="p">{</span> <span class="n">walked</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="p">}</span>
<span class="k">struct</span> <span class="n">Bear</span> <span class="p">{</span> <span class="n">walked</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="p">}</span>

<span class="k">trait</span> <span class="n">Walk</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">walk</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Walk</span> <span class="k">for</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">walk</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.walked</span> <span class="o">=</span> <span class="k">true</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Walk</span> <span class="k">for</span> <span class="n">Bear</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">walk</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.walked</span> <span class="o">=</span> <span class="k">true</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">walk_pet</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="n">Walk</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pet</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Try setting `pet.walked` here!</span>
    <span class="c">// You can't!</span>
    <span class="n">pet</span><span class="nf">.walk</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">walk_pet_2</span><span class="p">(</span><span class="n">pet</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Walk</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Try setting `pet.walked` here!</span>
    <span class="c">// You can't!</span>
    <span class="n">pet</span><span class="nf">.walk</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rover</span> <span class="o">=</span> <span class="n">Dog</span> <span class="p">{</span> <span class="n">walked</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span> <span class="p">};</span>
    <span class="nf">walk_pet</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">rover</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rover</span><span class="py">.walked</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can also use a different <code class="highlighter-rouge">where</code> syntax as function signatures with complex generics can get rather long.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">walk_pet</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pet</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">)</span>
<span class="n">where</span> <span class="n">W</span><span class="p">:</span> <span class="n">Walk</span> <span class="p">{</span>
    <span class="n">pet</span><span class="nf">.walk</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If you have multiple generics you can comma seperate them in both cases. If you’d like more than one trait contraint you can use <code class="highlighter-rouge">where W: Walk + Read</code> or <code class="highlighter-rouge">&lt;W: Walk + Read&gt;</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">stuff</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">R</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">)</span>
<span class="n">where</span> <span class="n">W</span><span class="p">:</span> <span class="n">Write</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">Read</span> <span class="o">+</span> <span class="n">Clone</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Look at all of the information you can derive from that function signature! It’s not helpfully named but you can still tell <em>almost for sure</em> what it does!</p>

<p>There are also these crazy things called <strong>Associated Types</strong> which are used in stuff like <code class="highlighter-rouge">Iterator</code>. When being written in a signature you want to use something like <code class="highlighter-rouge">Iterator&lt;Item=Dog&gt;</code> to say an iterator of <code class="highlighter-rouge">Dog</code>s.</p>

<h1 id="passing-functions">Passing Functions</h1>

<p>Sometimes it’s desirable to pass functions into other functions. In Rust, accepting a function as an argument is fairly straightforward. Functions have traits and they are passed like generics!</p>

<blockquote>
  <p>You should definitely use the <code class="highlighter-rouge">where</code> syntax here.</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="n">walked</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">do_with</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dog</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Dog</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span>
<span class="n">where</span> <span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Dog</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">action</span><span class="p">(</span><span class="n">dog</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">walk</span><span class="p">(</span><span class="n">dog</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Dog</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dog</span><span class="py">.walked</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rover</span> <span class="o">=</span> <span class="n">Dog</span> <span class="p">{</span> <span class="n">walked</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span> <span class="p">};</span>
    <span class="c">// Fn</span>
    <span class="nf">do_with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">rover</span><span class="p">,</span> <span class="n">walk</span><span class="p">);</span>
    <span class="c">// Closure</span>
    <span class="nf">do_with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">rover</span><span class="p">,</span> <span class="p">|</span><span class="n">dog</span><span class="p">|</span> <span class="n">dog</span><span class="py">.walked</span> <span class="o">=</span> <span class="k">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Functions in Rust implement traits which determine where (and how) they are passed:</p>

<ul>
  <li><a href="https://doc.rust-lang.org/stable/core/ops/trait.FnOnce.html"><code class="highlighter-rouge">FnOnce</code></a> - Takes a by-value reciever.</li>
  <li><a href="https://doc.rust-lang.org/stable/core/ops/trait.FnMut.html"><code class="highlighter-rouge">FnMut</code></a> - Takes a mutable reciever.</li>
  <li><a href="https://doc.rust-lang.org/stable/core/ops/trait.Fn.html"><code class="highlighter-rouge">Fn</code></a> - Takes a immutable reciever.</li>
</ul>

<p>A particular <a href="http://stackoverflow.com/a/30232500/2084424">Stack Overflow answer</a> summises the differences very well:</p>

<blockquote>
  <p>A closure <code class="highlighter-rouge">|...| ...</code> will automatically implement as many of those as it can.</p>
</blockquote>

<blockquote>
  <ul>
    <li>All closures implement <code class="highlighter-rouge">FnOnce</code>: a closure that can’t be called once doesn’t deserve the name. Note that if a closure only implements <code class="highlighter-rouge">FnOnce</code>, it can be called only once.</li>
    <li>Closures that don’t move out of their captures implement <code class="highlighter-rouge">FnMut</code>, allowing them to be called more than once (if there is unaliased access to the function object).</li>
    <li>Closures that don’t need unique/mutable access to their captures implement <code class="highlighter-rouge">Fn</code>, allowing them to be called essentially everywhere.</li>
  </ul>
</blockquote>

<p>Essentially, the differences between the different types is how they interact with their environment. In my experience, you only <em>really</em> need to worry about the distinction for Closures, which may capture variables in scope (in our above example, the <code class="highlighter-rouge">main()</code> function).</p>

<p>Have no fear, though! The compiler messages when one type is provided when another are needed are very helpful!</p>

<h1 id="lifetimes">Lifetimes</h1>

<p>So, you’re probably feeling pretty good about yourself right now. I mean, look at that scrollbar, it’s almost to the bottom of the page! You’ll be a Rust function signature <strong>master</strong> in no time!</p>

<p>Let’s finish up with a bit of talk about lifetimes because you’ll eventually come across them and likely get quite confused.</p>

<blockquote>
  <p>Let me be honest with you upfront here. Lifetimes are an arcane art to me. I used them a bit back in 0.7-0.10 and then I haven’t really had to use them since. If you know really anything at all about them you’re much more qualified to write this section than I am.</p>
</blockquote>

<p>Modern Rust has a really robust and effective <em>lifetime ellision</em> which removes the vast majority of lifetime gymnastics we used to need to concern ourselves with. But <em>when</em> you do things can start to untangle.</p>

<p>So, if you start dealing with a lot of lifetimes, your first step should really be to <strong>sit back and think about it</strong>. Unless your code is quite complex it’s quite likely you won’t need to deal with lifetimes. If you’re bumping into lifetimes in a simple example your notion of the problem is probably <strong>incorrect</strong>.</p>

<p>Here is a function with lifetimes from <a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.as_slice"><code class="highlighter-rouge">Option</code>’s implementation</a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">as_slice</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span>
</code></pre></div></div>

<p>Lifetimes are denoted by the tick (<code class="highlighter-rouge">'</code>) and given a name. In this case, <code class="highlighter-rouge">'a</code> but they can also be things like <code class="highlighter-rouge">'burrito</code> if you prefer inside jokes. Essentially what this is saying is:</p>

<blockquote>
  <p>The lifetime of the <code class="highlighter-rouge">Option&lt;T&gt;</code> this is called upon is the same as the lifetime of the returned <code class="highlighter-rouge">[T]</code></p>
</blockquote>

<p>Great! I’m really not qualified to write anymore about lifetimes but if you have anything to add let me know and I’ll credit you for sure.</p>

<h1 id="challenge-time">Challenge Time</h1>

<p>Below, you’ll find a set of functions pulled from the standard library along with links to their documentation. Can you tell from their function signature what they do? (For added fun, I’ve removed the function name!)</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// In `File`</span>
<span class="k">fn</span> <span class="n">name</span><span class="o">&lt;</span><span class="n">P</span><span class="p">:</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">P</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span>
</code></pre></div></div>
<p><a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create">Source</a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// In `Option&lt;T&gt;`</span>
<span class="k">fn</span> <span class="n">name</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">err</span><span class="p">:</span> <span class="n">E</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.ok_or">Source</a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// In `Iterator&lt;Item=T&gt;`</span>
<span class="k">fn</span> <span class="n">name</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">FromIterator</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">B</span>
<span class="n">where</span> <span class="n">Self</span><span class="p">:</span> <span class="n">Sized</span>
</code></pre></div></div>

<p><a href="https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html#method.collect">Source</a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// In `Iterator&lt;Item=T&gt;`</span>
<span class="k">fn</span> <span class="n">name</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">init</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">B</span>
<span class="n">where</span> <span class="n">Self</span><span class="p">:</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">B</span>
</code></pre></div></div>

<p><a href="https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html#method.fold">Source</a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// In `Result&lt;T,E&gt;`</span>
<span class="k">fn</span> <span class="n">name</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">O</span><span class="p">:</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="n">O</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><a href="https://doc.rust-lang.org/stable/core/result/enum.Result.html#method.map_err">Source</a></p>

<p>I hope that went <strong>fantastically</strong>, I was just over here cheering you on!</p>

    </article>

    <aside class="post-meta">
  
    Posted on
    <time datetime="2015-07-10T00:00:00-07:00">10 Jul 2015</time>
  

  
    
      
        , into
        
        <span><a href="/tags/#rust">Rust</a></span>
      
    
      
        
             and
        
        <span><a href="/tags/#tutorials">Tutorials</a></span>
      
    .
  

  
</aside>

</main>

<footer class="post-footer">
    <h4>By Pranay Singh</h4>

    Connect through
    
        <a href="mailto:zeppez@protonmail.com">zeppez@protonmail.com</a>,
    

    
        <a href="https://github.com/shitbox">@shitbox</a> on Github,
    

    

    or track via <a class="subscribe" href="/feed.xml">RSS Feed</a>.
</footer>


    </body>

</html>
