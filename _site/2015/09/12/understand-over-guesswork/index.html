<!DOCTYPE html>
<html>
    <head>
    <!-- Fun compatability things -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">                  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="shortcut icon" href="/assets/images/favicon.ico">

    <!-- Information about this site -->
    <title>Understanding Over Guesswork</title>
    <meta name="description" content="Exploring, fascinating and amusing" />

    <!-- Various Twitter related content. -->
    
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:image" content="http://0.0.0.0:4000/assets/images/2015/09/mountains.jpg">
    
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    
        <meta name="twitter:title" content="Understanding Over Guesswork">
    
    
        <meta name="twitter:description" content="&lt;h1 id=&quot;evolving-how-we-learn-systems-with-lessons-from-programming-in-the-large&quot;&gt;Evolving How We Learn Systems with Lessons from Programming in the Large&lt;/h1&gt;

">
    

    <!-- Talk about the homepage and the rss feed. -->
    <link rel="canonical" href="http://0.0.0.0:4000">
    <link rel="alternate" type="application/rss+xml" href="/feed.xml">

    <!-- Stylesheets are fun -->
    <link rel="stylesheet" href="/assets/font/fira_code.css">
    <link rel="stylesheet" type="text/css" media="screen" href="/assets/main.css" />

    <!-- Include Katex if it's necessary. -->
    

    <script defer>
        // Create captions from Alt tags
        document.addEventListener("DOMContentLoaded", function(event) {
            Array.from(document.querySelectorAll("main img")).forEach(function (item) {
                if (item.attributes['alt']) {
                    var caption = document.createElement("figcaption");
                    caption.innerHTML = item.attributes['alt'].value;
                    item.outerHTML = "<figure>" + item.outerHTML + caption.outerHTML + "</figure>";
                }
            });
        });
    </script>
</head>


    <body>
        <header>
  <div id="cover-wrapper">
    
      <img id="cover" src="/assets/images/2015/09/mountains.jpg">
    
  </div>

  <div class="title">
    
      <h1><a href="/">Understanding Over Guesswork</a></h1>
    
  </div>


  <nav id="pages">
    <ul>
      <li><a href="/">Index</a></li>
      
        
          <li>
            <a class="" href="/about/">
              About
            </a>
          </li>
        
      
        
      
        
      
        
      
        
          <li>
            <a class="" href="/projects/">
              Projects
            </a>
          </li>
        
      
        
          <li>
            <a class="" href="/tags/">
              Tags
            </a>
          </li>
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    </ul>
  </nav>
</header>


<main>
    <article>
        <h1 id="evolving-how-we-learn-systems-with-lessons-from-programming-in-the-large">Evolving How We Learn Systems with Lessons from Programming in the Large</h1>

<blockquote>
  <p>Some bugs are just that—a one off.  A wayward moth that just happens to be innocently fluttering through the wrong relay at the wrong time.  But some kinds of bugs aren’t like that.  Instead, they have risen to superstar status, plaguing veterans and newcomers alike.  But what if these aren’t bugs at all?  What if they are actual deficiencies in safety and robustness offered by the C programming language as a consequence of the degree to which guesswork is introduced.  Here we explore a more explicit approach to systems level programming supported by Rust, which we believe will better promote understanding of design intent, and eliminate some of the guesswork.  Guided by a set of classic, but still relevant, bugs identified almost 15 years ago by Engler, we consider this in the context of the new generation of students learning about systems in a typical OS course, where students often first encounter these deficiencies.</p>
</blockquote>

<h1 id="1-introduction">1. Introduction</h1>

<p>Concurrency, parallelism, memory management, process scheduling, deadlocks, mutexes, system calls, filesystems, and architectural considerations are all commonly taught concepts in Operating Systems courses. These topics can be a struggle to understand, even for determined students, due to their complex, low-level characteristics.</p>

<p>Instructors may also find themselves struggling, as these assignments can be difficult to create, and at times nearly impossible to evaluate effectively. Instructors and their markers desire assignments which are simple enough to fit into a few files, demonstrate understanding of failure modes, can be tested effectively in an automated fashion, and show students the caveats of their attempts to solve the problem. In many cases, a trade-off is necessary. For example, building an interactive shell is a common, and much loved, assignment in which instructors must balance the number of features required with the time provided. Features such as pipes, background tasks, tab-completion, and environment variables are all desirable and interesting to implement, but contribute greatly to the complexity of the code, as well as the amount of time it takes to evaluate.</p>

<p>On top of the complexity, the ambiguity of language features means that year after year new students hit the same old bugs—eventually.  Engler et al. <a href="https://web.stanford.edu/~engler/deviant-sosp-01.pdf" title="Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code"><em>(ref)</em></a> identified a number of problem classes in their work in static analysis that has served as a foundation for many tools in systems <a href="http://doi.acm.org/10.1145/2039239.2039241" title="Finding Resource-release Omission Faults in Linux"><em>(ref)</em></a>, <a href="http://doi.acm.org/10.1145/1133373.1133405" title="Applying Source-code Verification to a Microkernel: The VFiasco Project"><em>(ref)</em></a>, applications <a href="http://dl.acm.org/citation.cfm?id=1883978.1883982" title="Detecting Missing Method Calls in Object-oriented Software"><em>(ref)</em></a>, <a href="http://dl.acm.org/citation.cfm?id=1883978.1883982" title="Statically Checking API Protocol Conformance with Mined Multi-object Specifications"><em>(ref)</em></a>  and even compiler extensions derived from hardware specifications <a href="http://doi.acm.org/10.1145/2666357.2597823" title="em-SPADE: A Compiler Extension for Checking Rules Extracted from Processor Specifications"><em>(ref)</em></a>.  Students and professionals alike are perplexed by seemingly simple questions such as:</p>

<ul>
  <li>Can routine <code class="highlighter-rouge">F</code> fail?</li>
  <li>Must <code class="highlighter-rouge">A</code> be paired with <code class="highlighter-rouge">B</code>?</li>
  <li>Does security check <code class="highlighter-rouge">Y</code> protect <code class="highlighter-rouge">X</code>?</li>
  <li>Can <code class="highlighter-rouge">A</code> be done after <code class="highlighter-rouge">B</code>?</li>
  <li>Does lock <code class="highlighter-rouge">L</code> protect <code class="highlighter-rouge">V</code>?</li>
</ul>

<p>In this short paper we demonstrate precisely how Rust addresses these potential bugs in a clear, clean, safe and robust manner. After introducing Rust (Section 2), we discuss how Rust approaches and helps solve to these common bug categories (Section 3). We also discuss the goals of “Safety”, the state of tooling, and the Rust community (Section 4), before closing with Future Work (Section 5).</p>

<h1 id="2-introducing-rust">2. Introducing Rust</h1>

<p>Rust <a href="http://rust-lang.org/" title="Rust"><em>(ref)</em></a> is a systems oriented ML-family language supported by Mozilla Research. It was originally conceived by Graydon Hoare and reached its first stable release on May 15, 2015 <a href="http://blog.rust-lang.org/2015/05/15/Rust-1.0.html" title="Announcing Rust 1.0"><em>(ref)</em></a>. It is dual licensed Apache and MIT, fully open source, and governed through an extensive Request For Comment (RFC) process.</p>

<p>Rust offers a robust set of desirable features for systems code: ahead-of-time compilation, zero-cost abstractions, move semantics, guaranteed memory safety, threads without data races, trait-based generics, pattern matching, type inference, minimal runtime (removable, <a href="http://doc.rust-lang.org/book/no-stdlib.html" title="libcore"><em>(ref)</em></a>), no garbage collector or VM necessary, efficient C bindings and robust static analysis</p>

<p>It accomplishes these features through a number of novel techniques largely built off its type system and the borrow checker. The Rust community has been working to firmly position Rust as a powerful tool for programming in ultra-large, <a href="https://www.sei.cmu.edu/uls/" title="Ultra-Large-Scale Systems: The Software Challenge of the Future"><em>(ref)</em></a>, embedded, and networking systems.</p>

<h2 id="21-rust-basics">2.1 Rust Basics</h2>

<p>To someone familiar with C/C++ the syntax of Rust will appear reasonably familiar. Rust differs in many ways though, believing in that it is better to be explicit and promote understanding of what is occurring, than to expect the programmer to maintain all of this information in their head and engage in guesswork.</p>

<p>This is a key motivating factor behind our proposed adoption of Rust in OS courses, we believe this quality does not do away with conciseness or elegance of code. Community members have developed bindings for well-known tools like Redis <a href="http://redis.io/" title="Redis"><em>(ref)</em></a> and found the APIs for equivalent Rust and Python actions of relatively similar “feel”, despite the benefits of Rust’s type system providing an additional safety net <a href="http://lucumr.pocoo.org/2014/10/1/a-fresh-look-at-rust/#designing-apis" title="A Fresh Look at Rust"><em>(ref)</em></a>.</p>

<p>Rust does, however, have significant semantic differences compared to C-like languages. For variable declaration, Rust has the <code class="highlighter-rouge">let</code> keyword which is <em>immutable by default</em>, mutability is opt-in via <code class="highlighter-rouge">let mut</code>. This opt-in mutability was found by the community to encourage better code. Instead of the programmer needing to remember to use <code class="highlighter-rouge">const</code> the compiler informs them of any variables they might have forgotten to make mutable or if it is unnecessarily mutable.</p>

<p>As well, function definitions differ from C-like languages. This change makes function definitions easier to comprehend when dealing with complex parameters, generics, and return values. Numerous reasoning for why C’s declaration syntax is inadequate were well explained by Rob Pike <a href="https://blog.golang.org/gos-declaration-syntax" title="Go Blog: Function Declaration"><em>(ref)</em></a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">example_simple</span><span class="p">()</span>
<span class="k">fn</span> <span class="nf">example_params</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">u64</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">u64</span><span class="p">)</span>
<span class="k">fn</span> <span class="nf">example_returns</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span>
<span class="k">fn</span> <span class="n">example_generic</span><span class="o">&lt;</span><span class="n">U</span><span class="p">:</span> <span class="n">Read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reader</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span>
<span class="k">fn</span> <span class="n">example_generic_alt</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reader</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span>
    <span class="n">where</span> <span class="n">U</span><span class="p">:</span> <span class="n">Read</span>
</code></pre></div></div>

<h2 id="22-a-strong-type-system">2.2 A Strong Type System</h2>

<p>While a dynamic type system is desirable in some areas, particularly in higher level code, things like implicit, possibly lossy data conversions can often be dangerous in system code. In our experience, many operating systems students also struggle with the mental concepts of pointers and their uses. This can lead to taking pointers as values and performing pointer arithmetic.</p>

<p>The programmer is not <em>prevented</em> from doing these things in Rust, it only ensures that it is actually the intended action. For many students though, attempting to cast pointers into a value is actually a mistake in their intention. Rust helps users with this by automatically dereferencing pointers when necessary, and providing stronger tools for common places where these mistakes crop up, like string indexing or dynamic array access.</p>

<p>Types can be created easily, and there are three basic compound data structures, <code class="highlighter-rouge">struct</code>, <code class="highlighter-rouge">enum</code>, and tuples. <code class="highlighter-rouge">struct</code>s and tuples are similar to other languages. Rust’s <code class="highlighter-rouge">enum</code>s are able to represent variants with encapsulated values, generics, and even <code class="highlighter-rouge">struct</code>s!</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Structure with generic</span>
<span class="k">struct</span> <span class="n">One</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">bar</span><span class="p">:</span> <span class="n">T</span>
<span class="p">}</span>
<span class="c">// 2-tuple</span>
<span class="k">struct</span> <span class="nf">Two</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">);</span>
<span class="c">// Enum</span>
<span class="k">enum</span> <span class="n">Three</span> <span class="p">{</span>
    <span class="c">// Plain.</span>
    <span class="n">Foo</span><span class="p">,</span>
    <span class="c">// Variant with Tuple.</span>
    <span class="nf">Bar</span><span class="p">(</span><span class="nb">usize</span><span class="p">),</span>
    <span class="c">// Variant with Struct.</span>
    <span class="n">Baz</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="23-we-dont-need-a-null">2.3 We Don’t Need A <code class="highlighter-rouge">null</code></h2>

<p>Cited by its creator <a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" title="The Billion Dollar Mistake"><em>(ref)</em></a> as a ‘billion-dollar mistake’ <code class="highlighter-rouge">null</code> is one of the most dangerous thorns in a programmers toolbox. What’s more is that these errors happen at <em>runtime</em> and may take down live systems.</p>

<p>In languages like C, C++, and Java a tremendous amount of research and development time has gone into developing products like Coverity <a href="https://www.coverity.com/" title="Coverity"><em>(ref)</em></a> and PVS-Studio <a href="http://www.viva64.com/en/pvs-studio/" title="PVS-Studio"><em>(ref)</em></a> to help discover possible null pointer inconsistencies. Engler et al suggest heuristic methods to determine the ‘null state’ of a variable throughout the control flow of a program. What if programmers could just stop worrying about <code class="highlighter-rouge">null</code> all together?</p>

<p>Many functional languages like Haskell and F# have the concept of an <code class="highlighter-rouge">Option</code>, a concept that Rust shares. Instead of needing to be aware of and check for <code class="highlighter-rouge">null</code> at every occurrence, the language semantics require the programmer to explicitly decide on the control flow for all values.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Create a `Some(T)` and a None.</span>
<span class="k">let</span> <span class="n">maybe_foo</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">let</span> <span class="n">not_foo</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
<span class="c">// Unwrapping.</span>
<span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">maybe_foo</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="k">let</span> <span class="n">default</span> <span class="o">=</span> <span class="n">not_foo</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">let</span> <span class="n">matched</span> <span class="o">=</span> <span class="k">match</span> <span class="n">maybe_foo</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="p">,</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="err">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="c">// Mapping</span>
<span class="k">let</span> <span class="n">mapped</span> <span class="o">=</span> <span class="n">maybe_foo</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">);</span>
</code></pre></div></div>

<h1 id="3-rust-reducing-bugs-through-linguistic-features">3. Rust: Reducing Bugs through Linguistic Features</h1>
<p>In Rust, many common bugs can be prevented because: routines with the potential for failure carry it explicitly in their function signature (Section 3.1), RAII is used to ensure allocations are followed by frees (Section 3.2), security checks can be required by the type system or through marker traits for ‘tainted’ data (Section 3.3), powerful move semantics eliminate use-after-free errors (Section 3.4), and locks inherently protect data, not code (Section 3.4).</p>

<h2 id="31-results-and-try">3.1 Results and <code class="highlighter-rouge">try!()</code></h2>

<p>When working with traditional languages such as C and C++ it can often be difficult to answer the question “Can this function fail?” Checked exceptions can help, but often APIs are inconsistent, and checks for failure can be forgotten <a href="https://web.stanford.edu/~engler/deviant-sosp-01.pdf" title="Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code"><em>(ref)</em></a>. Some static analysis techniques can be used to determine possible missed failure checks, such has detecting invocations that do check for error. Having failure information included in the function’s signature and requiring it to be explicitly checked may be a more robust solution over heuristics though.</p>

<p>The <code class="highlighter-rouge">Result&lt;T, E&gt;</code> enum exists as either <code class="highlighter-rouge">Ok(T)</code> or <code class="highlighter-rouge">Err(E)</code> and conveys the result of something which may fail with an error. Using Rust’s <code class="highlighter-rouge">match</code> expression the user can act on various error conditions or success.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>
<span class="c">// Create an error. (Normally raised from lib)</span>
<span class="k">let</span> <span class="n">error</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">Other</span><span class="p">,</span>
    <span class="s">"I'm an example error!"</span><span class="p">);</span>
<span class="c">// The two result variants. Type notations usually</span>
<span class="c">// not necessary except in small examples.</span>
<span class="k">let</span> <span class="n">success</span><span class="p">:</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">Ok</span><span class="p">(</span><span class="s">"Success!"</span><span class="p">);</span>
<span class="k">let</span> <span class="n">failure</span><span class="p">:</span> <span class="n">Result</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="c">// Return either the value or the error description.</span>
<span class="k">let</span> <span class="n">val_or_desc</span> <span class="o">=</span> <span class="k">match</span> <span class="n">success</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">val</span><span class="p">,</span>
    <span class="nf">Err</span><span class="p">(</span><span class="k">ref</span> <span class="n">e</span><span class="p">)</span>  <span class="k">=&gt;</span> <span class="n">e</span><span class="nf">.description</span><span class="p">(),</span>
<span class="p">};</span>
</code></pre></div></div>

<p>It is a compiler warning to perform an action such as <code class="highlighter-rouge">file.read_to_string(buf)</code> which returns a <code class="highlighter-rouge">Result&lt;usize, Error&gt;</code> and to not handle the error in some way. In Rust is it idiomatic for any recoverable error to be passed up the call stack to where it can be sensibly handled. While approaching this idea newcomers typically struggle with the fact that an <code class="highlighter-rouge">io::Error</code> and a <code class="highlighter-rouge">Utf8Error</code> are different types and cannot be returned in the same <code class="highlighter-rouge">Result&lt;T,E&gt;</code>, since the <code class="highlighter-rouge">E</code> value would differ and violate Rust’s strong typing. This is typically solved by creating a new <code class="highlighter-rouge">Error</code> which is an enumeration over the possible underlaying errors as well as any the programmer may wish to include themselves. Then there are the <code class="highlighter-rouge">Into&lt;T&gt;</code> and <code class="highlighter-rouge">From&lt;T&gt;</code> traits which can be implemented to provide seamless interaction.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">enum</span> <span class="n">MyError</span> <span class="p">{</span>
    <span class="nf">Io</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="p">),</span>
    <span class="nf">Utf8</span><span class="p">(</span><span class="n">Utf8Error</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">From</span><span class="o">&lt;</span><span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">MyError</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span><span class="p">:</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Error</span> <span class="p">{</span>
        <span class="nn">Error</span><span class="p">::</span><span class="nf">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c">// ...</span>
</code></pre></div></div>

<p>When working with functions which may return a <code class="highlighter-rouge">Result&lt;T, E&gt;</code> it is common to use the <code class="highlighter-rouge">try!()</code> macro. This macro expands to either unwrap the <code class="highlighter-rouge">T</code> value inside and assign it, or return the error up the call stack. This helps reduce visual ‘noise’ and assist in composition.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">open_and_read</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">MyError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="nd">try!</span><span class="p">(</span><span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">));</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">num_read</span> <span class="o">=</span> <span class="nd">try!</span><span class="p">(</span><span class="n">f</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">));</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Error handling in Rust is explicit, composable, and sane. There are no exceptions, nulls, ‘magic numbers’ (like -1) or anything that may prevent the programmer from handling the error as <em>they</em> choose to, even if that is to simply <code class="highlighter-rouge">.unwrap()</code> it and fail. It’s worth noting that even <code class="highlighter-rouge">.unwrap()</code>ing does not actually crash the program as normally it unwinds the stack, isolating failure to a single thread and preventing inconsistent state.</p>

<h2 id="32-borrow-and-move-forget-free">3.2 Borrow and Move: Forget <code class="highlighter-rouge">free()</code></h2>

<p>In Rust there is the notion of moving, copying, and referencing. In some ways Rust’s memory model
is similar to C/C++’s. It features a powerful pointer system that allows programmers to make fine-grain, informed decisions about how values are stored, passed, and represented. Like C++, Rust makes use of a concept called Resource Acquisition Is Instantiation (RAII). Rust goes a step further, introducing the distinction between <em>immutably borrowing</em> (<code class="highlighter-rouge">&amp;</code>), <em>mutably borrowing</em> (<code class="highlighter-rouge">&amp;mut</code>), <em>copying</em> (<code class="highlighter-rouge">Copy</code> trait), and <em>moving</em> values. At any given time there may be any number of <em>immutable borrows</em>, meanwhile there may only be one <em>mutable borrow</em>, and a value may not be used in the function once it has been <em>moved</em> out.</p>

<p>This makes it simple for a programmer to observe a function signature and determine which values the function may mutate or consume, and which it may return. Using this information the compiler is able to determine the lifetime constraints of almost any value without additional notations. In (rare, complex) cases where it does require additional information, the programmer can annotate lifetimes just as they would generic type parameters.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// An owned, growable,</span>
    <span class="c">// non-copyable string.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">foo</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"foo"</span><span class="p">);</span>

    <span class="c">// Introduce a new scope.</span>
    <span class="p">{</span>
        <span class="c">// Reference bar is created.</span>
        <span class="k">let</span> <span class="n">bar</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>
        <span class="c">// Error, bar is immutable.</span>
        <span class="n">bar</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>
    <span class="p">}</span> <span class="c">// bar is destroyed.</span>

    <span class="c">// Error, bar does not exist.</span>
    <span class="k">let</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span>
    <span class="c">// Works, reference mutable.</span>
    <span class="k">let</span> <span class="n">rad</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">foo</span><span class="p">;</span>
    <span class="n">rad</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>
<span class="p">}</span> <span class="c">// foo is destroyed.</span>
</code></pre></div></div>

<p>This behavior is very similar to C++’s RAII facilities and ensures all values are safely destructed in a consistent, predictable manner as soon as they are no longer needed. The programmer does not need to worry about making sure each of their <code class="highlighter-rouge">malloc()</code> calls have a corresponding <code class="highlighter-rouge">free()</code> or rely on an outside tool <a href="https://web.stanford.edu/~engler/deviant-sosp-01.pdf" title="Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code"><em>(ref)</em></a> to discover such errors. The borrow checker is also able to determine when a value has been <em>moved</em> into a function call and should not be further used in the caller, eliminating another possible class of errors.</p>

<h2 id="33-traits-zero-cost-abstractions">3.3 Traits: Zero-cost Abstractions</h2>

<p>Rust does not use a class based or inheritance based system. Data is stored in <code class="highlighter-rouge">struct</code>s, primitives, or <code class="highlighter-rouge">enum</code>s which implement a set of traits that define how it interacts and which functions are available to it. For example, the <code class="highlighter-rouge">File</code> is a <code class="highlighter-rouge">struct</code> which implements <code class="highlighter-rouge">Read</code> and <code class="highlighter-rouge">Write</code> among other traits. Other structures like <code class="highlighter-rouge">TcpStream</code> and <code class="highlighter-rouge">UdpSocket</code> also implement the same <code class="highlighter-rouge">Read</code> and <code class="highlighter-rouge">Write</code> trait. Traits are zero-cost abstractions that act to encourage common interfaces and capabilities between like-structures <a href="http://blog.rust-lang.org/2015/05/11/traits.html" title="Abstraction without overhead: traits in Rust"><em>(ref)</em></a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Thing</span> <span class="p">{</span>
    <span class="n">barred</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="c">// Implementor must define.</span>
    <span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>
    <span class="c">// Default definition.</span>
    <span class="k">fn</span> <span class="nf">do_bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="nf">.bar</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">Thing</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.barred</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Traits fit easily together, are widespread in their implementation, and allow for common interfaces between modules to permit better adaptability. Traits can also be used as ‘markers’ in design patterns like state machines to provide additional compile time verification of correctness.</p>

<h2 id="34-static-analysis-at-the-core">3.4 Static Analysis at the Core</h2>

<p>Static analysis tools, like <code class="highlighter-rouge">splint</code> for C <a href="http://splint.org/" title="Splint"><em>(ref)</em></a> are an invaluable tool for Operating Systems programming, particularly when working on large codebases with multiple programmers.  Rust’s type system and region based memory, based on Cyclone <a href="http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf" title="Region-Based Memory Management in Cyclone"><em>(ref)</em></a>, are particularly well suited to static analysis. Indeed, <code class="highlighter-rouge">rustc</code> itself performs a tremendous amount of static analysis without the help of external tools. The type system carries all the information necessary for the compiler to understand all possible control flows of the program, all possible (recoverable) errors which arise, and the lifetimes of each region of memory.</p>

<p>Of particular interest is <code class="highlighter-rouge">rustc</code>’s “Borrow Checker” which analyzes and understands the pointer system and is able to verify data safety, even across multiple threads. The borrow checker is an area of active research <a href="ftp://ftp.cs.washington.edu/tr/2015/03/UW-CSE-15-03-02.pdf" title="Patina: A Formalization of the Rust Programming Language"><em>(ref)</em></a>.  As a result of the static analysis done by <code class="highlighter-rouge">rustc</code> it is able to infer information about (but is not limited to):</p>

<ul>
  <li>Unused results, variables and functions.</li>
  <li>Unreachable code.</li>
  <li>Unsafe pointer sharing (multiple mutable pointers.)</li>
  <li>Incorrect type matching and lossy casts.</li>
  <li>Use-after-free errors.</li>
  <li>Unclear lifetimes (asking for either clarity or refactoring.)</li>
</ul>

<h2 id="35-threads-that-dont-bite">3.5 Threads that don’t Bite</h2>

<p>Threading is perhaps one of the most powerful and robust features of Rust. The characteristics detailed above culminate in a sort of <em>tour de force</em> when used bravely in a threaded context.</p>

<p>Harnessing the power of ownership semantics, the type system, the standard library’s threading modules there are a number of tools available <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" title="Fearless Concurrency"><em>(ref)</em></a>:</p>

<p><strong>Channels</strong> provide a way to transfer messages (and ownership) between threads without fear of there being later (unsafe) access to the data by other threads. The default channel provided by the standard library is a Multiple-Producer, Single-Consumer channel.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::{</span><span class="n">channel</span><span class="p">,</span> <span class="n">Sender</span><span class="p">,</span> <span class="n">Receiver</span><span class="p">};</span>
<span class="k">let</span> <span class="p">(</span><span class="n">send</span><span class="p">,</span> <span class="n">receive</span><span class="p">)</span> <span class="o">=</span> <span class="nf">channel</span><span class="p">();</span>
</code></pre></div></div>

<p><strong>Locks</strong> can encapsulate data such that access is only granted if the lock is held. In Rust, you <strong>don’t lock code, you lock data</strong>, and it is safer because of it. Locks are typically represented by <code class="highlighter-rouge">Mutex</code>s and shared between threads with an Atomically Reference Counted structure (<code class="highlighter-rouge">Arc</code>). It should be noted that this design of locking data prevents a lock from being acquired and never given up, identified as common by Engler <a href="https://web.stanford.edu/~engler/deviant-sosp-01.pdf" title="Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code"><em>(ref)</em></a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">};</span>
<span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</code></pre></div></div>

<p><strong>Traits</strong> like <code class="highlighter-rouge">Sync</code> and <code class="highlighter-rouge">Send</code> are implemented on types and symbolize if it can be <em>sent</em> or <em>shared</em> between threads safely. These traits are not just documentation, they are intrinsic to the language.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Safe to share between threads.</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="n">Sync</span><span class="p">;</span>
<span class="c">// Safe to transfer between threads.</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="p">;</span>
</code></pre></div></div>

<p>Rust’s concurrency primitives are powerful and composable, allowing users to implement other, more fearless forms of concurrency such as <strong>sharing stack frames</strong>. For example, here’s a demonstration of a third-party crate called <strong>crossbeam</strong> that allows us to safely operate concurrently on stack-allocated data: <a href="http://aturon.github.io/crossbeam-doc/crossbeam/struct.Scope.html#method.spawn" title="crossbeam::Scope::spawn"><em>(ref)</em></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="n">crate</span> <span class="n">crossbeam</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

    <span class="nn">crossbeam</span><span class="p">::</span><span class="nf">scope</span><span class="p">(|</span><span class="n">scope</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">item</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">items</span> <span class="p">{</span>
            <span class="n">scope</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This same crate also provides primitives for building lock-free concurrent data structures without the overhead of a garbage collector <a href="http://aturon.github.io/blog/2015/08/27/epoch/" title="Lock-freedom without garbage collection"><em>(ref)</em></a>, again demonstrating Rust’s capacity for building safe, efficient, and reusable concurrent components.</p>

<h1 id="4-safety-tools-and-community">4. Safety, Tools, and Community</h1>

<p>The concept of “Safety” in code is often poorly defined, but can be considered in three categories:</p>

<ul>
  <li><strong>Type Safety</strong> prevents or discourages type errors, such as treating a <code class="highlighter-rouge">float</code> like an <code class="highlighter-rouge">int</code>. Rust and languages like Haskell excel here as their type systems are strong, explicit (but often inferred), and do not include the notion of a <code class="highlighter-rouge">null</code> that can go anywhere indiscriminately.</li>
  <li><strong>Memory Safety</strong> reduces or eliminates the possibility of mistakes like writing a 64 bit value into a 32 bit space (overwriting unintended data), or multi-threaded mutable access to the same memory. Rust’s borrow checker effectively eliminates data races in safe code and strong type safety prevents unintended clobbering.</li>
  <li><strong>Thread Safety</strong> prevents inter-thread race conditions, such as one thread exiting when another thread is waiting on data from it. Rust provides some robust tools for managing thread pools integrated into its type system, however some mistakes are still possible if the programmer works hard enough to accomplish them.</li>
</ul>

<p>Rust advertises both type safety and data safety. There is still research and development to be done before it can truly be considered thread-safe.</p>

<h2 id="41-tooling">4.1 Tooling</h2>

<p>Rust has a robust, opinionated set of tooling. The Rust standard distribution includes <code class="highlighter-rouge">rustc</code> (the compiler), <code class="highlighter-rouge">cargo</code> (a package manager and build tool), and <code class="highlighter-rouge">rustdoc</code> (a documentation generator). Currently there is work being done on a <code class="highlighter-rouge">rustfmt</code> which would function the same as Go’s venerable <code class="highlighter-rouge">gofmt</code>.</p>

<p>Package management via <code class="highlighter-rouge">cargo</code> is a feature Rust has inherited from several other modern languages. All package dependencies, build options, and tasks are defined in a <code class="highlighter-rouge">Cargo.toml</code> file. Dependencies are checked and (if necessary) pulled on <code class="highlighter-rouge">cargo build</code>, <code class="highlighter-rouge">test</code>, or <code class="highlighter-rouge">doc</code>.</p>

<p>Rust supports both <em>unit tests</em> and <em>integration tests</em> by default. Unit tests may appear wherever is appropriate in the code and are annotated by <code class="highlighter-rouge">#[test]</code>, it is common for designers to include a <code class="highlighter-rouge">test</code> module in their code. Integration tests are written in the <code class="highlighter-rouge">tests/</code> directory and allow a package to be tested as a depended upon library. Testing is done by simply invoking <code class="highlighter-rouge">cargo test</code> in the project directory. These features blow away barriers which programmers might face in other languages that would prevent them from bothering to test. Additionally, it makes marking Rust based projects very easy, all an instructor needs to do is provide (or replace) the <code class="highlighter-rouge">tests/</code> directory with an appropriate suite.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="n">test</span><span class="p">]</span>
<span class="k">fn</span> <span class="nf">test_passes</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="nd">#[test]</span>
<span class="nd">#[should_panic]</span>
<span class="k">fn</span> <span class="nf">test_fails</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="k">true</span> <span class="o">==</span> <span class="k">false</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Having a standardized, high quality documentation format is invaluable for programmers, and Rust facilitates this. Documentation comments can be placed anywhere in the code using <code class="highlighter-rouge">///</code> for function level documentation or <code class="highlighter-rouge">//!</code> for module level documentation. Documentation is in a common markdown format, code samples included in the documentation are automatically processed as unit tests. Generating documentation is done by <code class="highlighter-rouge">cargo doc</code>, which generates HTML and manpage documentation. Many Rust projects even go so far as to automate the unit testing and documentation generation step and hook it into their git commits <a href="http://hoverbear.org/2015/03/06/rust-travis-github-pages/" title="Rust, Travis, and Github Pages"><em>(ref)</em></a>.</p>

<h2 id="42-community">4.2 Community</h2>

<p>One of the biggest dangers in choosing a language that “Is not C” to teach operating systems in is that it can be very difficult for students to get help.  Mozilla’s IRC network hosts the popular #rust channel which regularly has over 800 members at any given time. <a href="http://crates.io/"><code class="highlighter-rouge">crates.io</code></a> hosts over 2300 packages. The language reached 1.0 on May 15, 2015 <a href="http://blog.rust-lang.org/2015/05/15/Rust-1.0.html" title="Announcing Rust 1.0"><em>(ref)</em></a> and has been in development since 2006. The community is active and friendly with a variety special interest groups.</p>

<p>Best of all, there is active operating system development in Rust. There is a project to develop <code class="highlighter-rouge">coreutils</code> <a href="https://github.com/uutils/coreutils" title="uutils/coreutils"><em>(ref)</em></a>, a kernel <a href="http://jvns.ca/blog/2014/03/12/the-rust-os-story/" title="Writing an OS in Rust in Tiny Steps"><em>(ref)</em></a>, operating systems <a href="https://scialex.github.io/reenix.pdf" title="Reenix: Implementing a Unix-Like Operating System in Rust"><em>(ref)</em></a>, and embedded system platforms <a href="http://zinc.rs/" title="zinc.rs"><em>(ref)</em></a>. At the time of writing, these projects are young enough that students could even contribute components upstream.</p>

<h1 id="50-conclusion-and-future-work">5.0 Conclusion and Future Work</h1>

<p>In this work we have overviewed some of the reasons to consider Rust as the lanugage for a new generation of systems programmers by highlighting precisely how Rust prevents classic bugs.  There is a considerable amount of research remaining regarding Rust’s uses in systems code and programming in the large in general. We seek to foster knowledge of the language at the University of Victoria and are working on developing distributed consensus algorithms like Raft <a href="http://ramcloud.stanford.edu/raft.pdf" title="In Search of an Understandable Consensus Algorithm"><em>(ref)</em></a> and next generation initialization systems in the spirit of OpenRC.</p>


    </article>

    <aside class="post-meta">
  
    Posted on
    <time datetime="2015-09-12T00:00:00-07:00">12 Sep 2015</time>
  

  
    
      
        , into
        
        <span><a href="/tags/#rust">Rust</a></span>
      
    
      
        
             and
        
        <span><a href="/tags/#uvic">UVic</a></span>
      
    .
  

  
</aside>

</main>

<footer class="post-footer">
    <h4>By Pranay Singh</h4>

    Connect through
    
        <a href="mailto:zeppez@protonmail.com">zeppez@protonmail.com</a>,
    

    
        <a href="https://github.com/shitbox">@shitbox</a> on Github,
    

    

    or track via <a class="subscribe" href="/feed.xml">RSS Feed</a>.
</footer>


    </body>

</html>
